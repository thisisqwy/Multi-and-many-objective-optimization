NSGA-II的算法步骤：假设父代数量为N，迭代计数器为t，最大迭代次数为Max。step1初始化父代并设置t=0、step2生成子代：用两次二元锦标赛选择父代1和父代2（需要注意的是第一次生成子代时的锦标赛选择进行比较时只看非支配等级，不看拥挤度，如果非支配等级一样就随机选一个），根据交叉概率和变异概率判断是否要交叉和变异，父代1和父代2进行SBX交叉得到子代1和子代2，子代1和2进行多项式变异得到新的子代1和子代2，不断重复直到子代数量和父代一样、step3进入循环(循环中止条件是t>=Max):step3.1得到新父代:合并父代和子代得到一个集合并进行非支配排序，假设得到rank1(级别反倒是最高的),rank2,...。按照级别将rank1,rank2,...的全部解放入新父代中并计算它们的拥挤度，直到此时父代的数量已经达到N，或者此时父代数量小于N但是rankl的全部解装不下，如果父代数量小于N，那此时计算rankl个体的拥挤度，将拥挤度从高到低放入新父代。step3.2用新父代生成新子代:类似第一次生成子代，不同点在于此后的锦标赛选择进行比较时即看非支配等级也看拥挤度。生成子代后t=t+1。并根据判断条件选择进入下一次循环还是结束。step4输出最终结果:将最后一次循环得到的父代和子代进行合并再进行快速非支配排序，将rank1的全部解作为最优解输出即可。  
NSGA-III的算法步骤：  
1.NSGA-II算法求解ZDT1问题，目标函数是极小值函数，目标函数有2个，自变量有30个，每个变量取值范围是[0,1]。大部分参考https://github.com/Jiangtao-Hao/NSGA-II
